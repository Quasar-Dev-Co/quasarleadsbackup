import { NextRequest, NextResponse } from 'next/server';
import dbConnect from '@/lib/mongodb';
import { IncomingEmail, AIResponse } from '@/models/emailResponseSchema';
import { emailService } from '@/lib/emailService';
import { Lead } from '@/models/leadSchema'; // Assuming Lead model might be useful

const OPENAI_API_KEY = process.env.OPENAI_API_KEY;

/**
 * Generates an AI-powered response using OpenAI GPT-3.5 Turbo.
 * @param email The incoming email object from the database.
 * @returns An object containing the generated subject, content, and a flag if the response was dropped.
 */
async function generateAIResponse(email: any): Promise<{ subject: string; content: string; isDropped: boolean; reasoning: string; }> {
  if (!OPENAI_API_KEY) {
    return { isDropped: true, subject: '', content: '', reasoning: 'OPENAI_API_KEY is not configured.' };
  }

  const systemPrompt = `You are a helpful and professional sales assistant for a company named QuasarLeads. Your goal is to provide a concise and helpful response to the user's email. Keep the response under 100 words. Structure your response in two lines:
SUBJECT: [Your subject line]
CONTENT: [Your email body]`;

  const userPrompt = `Here is the email you need to respond to:
FROM: ${email.leadName} (${email.leadEmail})
SUBJECT: ${email.subject}
CONTENT:
---
${email.content}
---
`;

  try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: 'gpt-3.5-turbo',
        messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }],
        max_tokens: 250,
            temperature: 0.7,
          }),
      signal: AbortSignal.timeout(15000), // 15-second timeout
        });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå OpenAI API Error: ${response.status} ${response.statusText}`, errorText);
      return { isDropped: true, subject: '', content: '', reasoning: `OpenAI API returned status ${response.status}` };
    }

          const data = await response.json();
    const aiContent = data.choices[0]?.message?.content?.trim();

    if (!aiContent) {
      return { isDropped: true, subject: '', content: '', reasoning: 'OpenAI response was empty.' };
    }

    const subject = aiContent.match(/SUBJECT: (.*)/)?.[1] || `Re: ${email.subject}`;
    const content = aiContent.match(/CONTENT: ([\s\S]*)/)?.[1]?.trim();

    if (!content || content.length < 15) {
      return { isDropped: true, subject: '', content: '', reasoning: 'AI content was too short or missing after parsing.' };
    }
    
    return {
      isDropped: false,
      subject,
      content,
      reasoning: 'Successfully generated by OpenAI.'
    };

  } catch (error: any) {
    if (error.name === 'TimeoutError') {
      console.error('‚ùå OpenAI API request timed out.');
      return { isDropped: true, subject: '', content: '', reasoning: 'OpenAI API request timed out.' };
    }
    console.error('‚ùå Failed to generate AI response:', error);
    return { isDropped: true, subject: '', content: '', reasoning: error.message };
  }
}


/**
 * Sends the reply and updates the database records.
 * @param email The original incoming email from the database.
 * @param reply An object containing the subject and content of the reply.
 * @param reasoning The reason or source of the reply.
 */
async function sendAndLogReply(email: any, reply: { subject: string, content: string }, reasoning: string): Promise<boolean> {
  const emailId = email._id.toString();

  // 1. Save the AI Response record
  const aiResponse = new AIResponse({
    incomingEmailId: emailId,
    generatedSubject: reply.subject,
    generatedContent: reply.content,
    status: 'sending',
    responseType: reasoning.startsWith('Successfully') ? 'ai_generated' : 'fallback',
    reasoning: reasoning,
  });
  await aiResponse.save();

  // 2. Prepare and send the email
  const emailConfig = {
    to: email.leadEmail,
    subject: reply.subject,
    text: reply.content,
    html: `<div style="font-family: Arial, sans-serif;">${reply.content.replace(/\n/g, '<br>')}</div>`,
  };

  try {
    const result = await emailService.sendEmail(emailConfig);
    if (!result.success) {
      throw new Error(result.error || 'SMTP Error');
    }

    // 3. Update records on successful send
    await AIResponse.findByIdAndUpdate(aiResponse._id, { status: 'sent', sentAt: new Date(), sentMessageId: result.messageId });
    await IncomingEmail.findByIdAndUpdate(emailId, { status: 'responded', respondedAt: new Date() });
    
    console.log(`‚úÖ Email sent successfully to ${email.leadEmail}. Message ID: ${result.messageId}`);
    return true;
      
    } catch (error: any) {
    console.error(`‚ùå Failed to send email to ${email.leadEmail}:`, error.message);
    await AIResponse.findByIdAndUpdate(aiResponse._id, { status: 'failed', lastError: error.message });
    return false;
  }
}

/**
 * Vercel Cron Job: Processes unread emails, generates AI responses, and sends them.
 */
export async function GET(): Promise<NextResponse> {
  console.log('üïê Cron Job: Starting email response processing...');
    await dbConnect();
    
  const emailsToProcess = await IncomingEmail.find({
    status: 'unread'
  }).limit(10).lean();

  if (emailsToProcess.length === 0) {
    console.log('‚úÖ No unread emails to process.');
    return NextResponse.json({ success: true, message: 'No unread emails to process.' });
  }
    
  console.log(`üìß Found ${emailsToProcess.length} emails to process.`);
  let successCount = 0;
  let failureCount = 0;
    
  for (const email of emailsToProcess) {
    console.log(`\nüîÑ Processing email from: ${email.leadEmail}, Subject: ${email.subject}`);
        
    // Mark as processing to prevent duplicate handling by other cron jobs
    await IncomingEmail.findByIdAndUpdate(email._id, { status: 'processing' });
    
    const aiResponse = await generateAIResponse(email);
    let reply: { subject: string, content: string };
    
    if (aiResponse.isDropped) {
      console.log(`üü° AI response dropped. Reason: ${aiResponse.reasoning}. Sending fallback.`);
      reply = {
        subject: `Re: ${email.subject}`,
        content: `Hi ${email.leadName},\n\nThank you for your message. We've received it and a member of our team will get back to you as soon as possible.\n\nBest regards,\nThe QuasarLeads Team`,
      };
            } else {
      console.log(`ü§ñ AI response generated successfully.`);
      reply = {
            subject: aiResponse.subject,
        content: `${aiResponse.content}\n\n--\n${email.leadName}`, // Add signature
      };
    }

    const success = await sendAndLogReply(email, reply, aiResponse.reasoning);
    if (success) {
      successCount++;
          } else {
      failureCount++;
      // Revert status to 'unread' for a retry on the next cron run
      await IncomingEmail.findByIdAndUpdate(email._id, { status: 'unread' });
      }
    }
    
    console.log(`\nüéâ Email processing completed!`);
  console.log(`- Success: ${successCount}`);
  console.log(`- Failures: ${failureCount}`);
    
    return NextResponse.json({
      success: true,
    message: 'Email processing completed.',
    stats: { processed: emailsToProcess.length, success: successCount, failures: failureCount }
  });
}

// Manual trigger for testing
export async function POST(): Promise<NextResponse> {
  console.log('üîß Manual trigger: Processing email responses...');
  return GET();
}