import mongoose from 'mongoose';

// Schema for incoming emails (replies from leads)
const incomingEmailSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: false, index: true },
  leadId: { type: mongoose.Schema.Types.ObjectId, ref: 'Lead', required: false }, // Optional link to a lead
  leadName: { type: String, required: true },
  leadEmail: { type: String, required: true },
  subject: { type: String, required: true },
  content: { type: String, required: true },
  htmlContent: { type: String, default: '' },
  status: {
    type: String,
    enum: ['unread', 'processing', 'pending_ai', 'responded', 'failed', 'processed'],
    default: 'unread'
  },
  receivedAt: { type: Date, default: Date.now },
  processedAt: { type: Date }, // When the cron job processed this email
  respondedAt: { type: Date }, // When user actually sent the response
  isReply: { type: Boolean, default: false }, // Whether this is a reply to our outgoing email
  isRecent: { type: Boolean, default: true }, // Whether this is from the last 20 minutes
  originalEmailId: { type: mongoose.Schema.Types.ObjectId, ref: 'IncomingEmail' }, // Reference to original email if this is a reply
  threadId: { type: String }, // Thread ID for email grouping
  sentiment: {
    type: String,
    enum: ['positive', 'negative', 'neutral', 'interested', 'not_interested'],
    default: 'neutral'
  },
  metadata: {
    messageId: String,
    inReplyTo: String,
    fromAddress: String,
    toAddress: String,
    references: String, // Email references header
    originalEmailStage: String, // Which stage of our email sequence this is replying to
    isReplyToSequence: Boolean // Whether this is a reply to our email sequence
  },
  // Conversation tracking for response limits
  conversationCount: { type: Number, default: 0 }, // How many times this lead has replied in this conversation
  conversationId: { type: String }, // Unique identifier for the conversation thread
  isThirdReply: { type: Boolean, default: false } // Flag to mark if this is the 3rd+ reply
}, {
  timestamps: true
});

// Schema for AI-generated responses
const aiResponseSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: false, index: true },
  incomingEmailId: { type: mongoose.Schema.Types.ObjectId, ref: 'IncomingEmail', required: true },
  generatedSubject: { type: String, required: true },
  generatedContent: { type: String, required: true },
  reasoning: { type: String, required: true },
  status: {
    type: String,
    enum: ['draft', 'sending', 'sent', 'failed'],
    required: true,
    default: 'draft'
  },
  responseType: { 
    type: String,
    enum: ['ai_generated', 'fallback', 'sequence_reply', 'final_template'], // Added final_template for 3rd reply
    default: 'ai_generated'
  },
  sentAt: { type: Date },
  sentMessageId: { type: String }, // SMTP Message-ID when sent
  lastError: { type: String },
  originalEmailStage: { type: String }, // Store which stage this response is for
  autoGenerated: { type: Boolean, default: false }, // Whether this was auto-generated
}, {
  timestamps: true
});


// Create indexes for better performance
incomingEmailSchema.index({ status: 1, receivedAt: -1 });
incomingEmailSchema.index({ isReply: 1, isRecent: 1 });
incomingEmailSchema.index({ leadEmail: 1, threadId: 1 });
incomingEmailSchema.index({ 'metadata.messageId': 1 });
incomingEmailSchema.index({ 'metadata.isReplyToSequence': 1 }); // Index for sequence replies
aiResponseSchema.index({ incomingEmailId: 1 });
aiResponseSchema.index({ responseType: 1 }); // Index for response types

// Export models
export const IncomingEmail = mongoose.models.IncomingEmail || mongoose.model('IncomingEmail', incomingEmailSchema);
export const AIResponse = mongoose.models.AIResponse || mongoose.model('AIResponse', aiResponseSchema); 